#include <CMSIS/stm32f10x.h>
#include "stm32f10x_gpio.h"
#include "stm32f10x_rcc.h"
#include "math.h"

/*
Частоту дискретизации устраиваю с помощью дополнительного таймера общего назначения. Создаю на его основе функцию задержки.

Задержка постоянна. Для того, чтобы менять сигнал по частоте, решил увеличивать или уменьшать число выводимых значений на период при постоянном значении задержки(частоты дискретизации).

Увеличением количества значений на период я увеличивал период синусоиды, тем самым уменьшая её частоту. 

Чем больше значений записываю, тем сильнее сужается синусоида, дабы влезть в установленный период.

Из справочных данных: 
- нота До 3ьей октавы: 1046 Гц 
- нота Ми 3ьей октавы: 1318 Гц 
- нота Соль 3ьей октавы: 1568 Гц

Частоту каждой ноты перевел в период. Посчитал сколько нужно выводить значений с имеющейся задержкой, дабы уместиться в найденный период.

Значения создавал по формуле синуса библиотечной.

Например:

Ми - 1318 Гц = 0,00076 с = 76 * 10^-5 c = 76 * 10 мкс.

(свои комменты)
Таймерный счетчик считает от 0 до значения в ARR. Если вы генерируете ШИМ, то когда счетчик меньше чем CCR - формируется положительный уровень,
как только счетчик стал больше CCR - формируется отрицательный уровень.
Но счетчик считает до ARR и сбрасывается! Поэтому значение CCR больше чем ARR указать можно, но бессмысленно. Просто всегда будет высокий уровень вместо ШИМа.

При предделителе и частоте 80 000 Гц ШИМа задержку таймер 3 дает 20 мкс. Но при увеличении до 160 000 Гц дает 10 мкс, то есть повлиял на работу второго таймера.

Для одновременного воспроизведения сразу нескольких нот складываю значения их текущих амлитуд (из массивов). 
Чтобы избежать переполнения,делю получившуюся сумму на количество звучащих нот. 
*/

#define PWM_PRESCALER 0
#define PWM_PERIOD 450                                      // частота ШИМа: 72 000 000/450 = 160 000 = 160 кГц   
                               				
#define TIMER_PERIOD 720                  							    // значения периода(количество тиков) для таймера, обеспечивающего задержку. 72 000 000/720  = 100 000 Гц = 0.00001 с = 10 мкс
                                                            
#define PORT_MANAGE_DYN GPIOA
#define PIN_MANAGE_DYN GPIO_Pin_1

#define pi 3.14159265358979323846

// типовой вариант функции assert
void assert_failed(uint8_t* file, uint32_t line)
{ 
  while (1)
  {
	;
  }
}

void Set_Pin()                                               // настройка подключения периферии
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE);     // тактирую порт А
	
  GPIO_InitTypeDef gpioStruct;                               // структура сигнального пина
  GPIO_StructInit(&gpioStruct);
	gpioStruct.GPIO_Speed = GPIO_Speed_2MHz;
	gpioStruct.GPIO_Mode = GPIO_Mode_AF_PP;                    // буду использовать альтернативный режим, а не обычный GPIO
	gpioStruct.GPIO_Pin = PIN_MANAGE_DYN;                      // настроим ногу (PА1) к которой подключен динамик
  GPIO_Init(PORT_MANAGE_DYN, &gpioStruct);
}

void Set_Timer()
{
	// настройка базового таймера
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);       // тактирую таймер 2
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);       // тактирую таймер 3
                                                             
	TIM_TimeBaseInitTypeDef Tim;                               // создаю экземпляр структуры, которая задает частоту через предделитель, период и направление счета
  TIM_TimeBaseStructInit(&Tim);                              // заполняю структуру значениями по умолчанию
	Tim.TIM_Prescaler = PWM_PRESCALER;                         // предделитель для таймера
	Tim.TIM_Period = PWM_PERIOD;                               // период 
	TIM_TimeBaseInit(TIM2, &Tim);                              // инициализирую таймер
     
	Tim.TIM_Prescaler = 7200;	
	Tim.TIM_Period = 100;        										            
	TIM_TimeBaseInit(TIM3, &Tim);  
	
	// настройка канала ШИМа
	TIM_OCInitTypeDef TimPWM;                                  // конфигурация выхода таймера. Структура для генерации ШИМ
	TIM_OCStructInit(&TimPWM);
	TimPWM.TIM_OCMode = TIM_OCMode_PWM1;                       // конфигурируем выход таймера, режим PWM1 
	TimPWM.TIM_OutputState = TIM_OutputState_Enable;           // выход включен
	TIM_OC2Init(TIM2, &TimPWM);                                // заношу данные во 2ой канал
	
	TIM_ITConfig(TIM2,TIM_IT_Update, ENABLE);                  // режим генерации прерывания по обновлению, переполнению
	TIM_ITConfig(TIM3,TIM_IT_Update, ENABLE);   
	TIM_Cmd(TIM2, ENABLE);                                     // запуск таймера
}

void Delay()                           			                 // функция, обеспечивающая задержку.
{ 	    
	TIM_Cmd(TIM3, ENABLE);         														 // в момент вызова произвести запуск таймера
	while((TIM3->SR & TIM_SR_UIF)==0)                          //дождаться конца задержки
	{
	}		
  TIM_ClearITPendingBit(TIM3,TIM_IT_Update);	               //сбросить флаг
}

uint16_t mi_sin[75] = {0};                                   // массив элементов для записи значений ноты Ми 38 при частоте выводе значения в 20 мкс.
uint16_t do_sin[95] = {0};                                   // массив элементов для записи значений ноты До 48 при частоте выводе значения в 20 мкс.
uint16_t sol_sin[63] = {0};                                  // массив элементов для записи значений ноты Ми 32 при частоте выводе значения в 20 мкс.

// функция расчета значений синусов
void Sine()                                                        
{  
	for (int j = 0; j <= 75; j++)
	{	
		mi_sin[j] = (uint16_t)((sin(j*pi/38)+1)*450/2);         // массив расчета значений синуса для ноты Ми
	}     																										// влезет в регистр не больше 450
	for (int j = 0; j <= 95; j++)
	{	
		do_sin[j] = (uint16_t)((sin(j*pi/48)+1)*450/2);        
	}     
	for (int j = 0; j <= 63; j++)
	{	
		sol_sin[j] = (uint16_t)((sin(j*pi/32)+1)*450/2);         
	}    
}

void Mi()
{    				 
	for(int i=0; i <= 75; i++)                              
	{                                         // у меня 758 отрезков длительностью 1 мкс.
		TIM2->CCR2 = mi_sin[i];                 // 758*10^-6 с = 0,000758 с = 1319 Гц
    Delay();		                            // задержка в 1 мкс. 
	}
}

void Do()
{    				 
	for(int i = 0; i <= 95; i++)                              
	{                                         // у меня 758 отрезков длительностью 1 мкс.
		TIM2->CCR2 = do_sin[i];                 // 758*10^-6 с = 0,000758 с = 1319 Гц
    Delay();		                            // задержка в 1 мкс. 
	}
}

void Sol()
{    				 
	for (int i = 0; i <= 63; i++)                             
	{                                          // у меня 758 отрезков длительностью 1 мкс.
		TIM2->CCR2 = sol_sin[i];                 // 758*10^-6 с = 0,000758 с = 1319 Гц
    Delay();		                             // задержка в 1 мкс. 
	}
}

// количество элементов в массиве аккорда = (76 + 96 + 64)/3 = 78
uint16_t chord_sin[77] = {0};  

// функция расчета значений синуса для аккорда
void Chord_Sine()                                                         
{                                          
	for (int j = 0; j <= 77; j++)
	{
		chord_sin[j] = (uint16_t)((do_sin[j] + mi_sin[j]+ sol_sin[j])/3);     
	}
} 

void Chord()
{
	for(int i = 0; i <= 77; i++)                                            
	{
		TIM2->CCR2 = chord_sin[i];                                             
		Delay();
	}
}


int main()
{
	Set_Pin();
	Set_Timer();
	Sine();
	Chord_Sine();
	while(1)
	{

// 		Chord();
  	Mi();
// 		Do();
// 		Sol();
	}
	return 0;
}
	