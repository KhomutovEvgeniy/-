#include <CMSIS/stm32f10x.h>
#include "stm32f10x_gpio.h"
#include "stm32f10x_rcc.h"
#include "math.h"

/*
Задаем частоту работы таймера: 1,8 МГц, что соответствет периоду в 1,8 мкс.
Таймер считает с частотой 1,8 МГц, отсчет ведется каждые 1,8 мкс.
Для этого предделитель дожен быть равен 40. Ибо 72000000/40 = 1800000 = 1,8 МГц.

Задаю ШИМ частота 200 кГц. Это частота дискретизации.
Период(T) = PERIOD/(72 МГц/PRESCALER)

Используется TIM2 CHANNEL 2.

Использую PA1 вместо PC8.

Надо подавать ШИМ с изменяющимся заполнением по закону синуса.
*/

#define PWM_PRESCALER 1
#define PWM_PERIOD 450                                       // частота дискретизации звука. При такой 72 000 000/450 = 160 000 = 160 кГц частоте громкость звучания меня устроила.  

#define TIMER_PRESCALER 720                                 // значения предделителя для таймера, обеспечивающего задержку. 72 000 000/720 = 100 000 Гц.
#define TIMER_PERIOD 10000                  							  // значения периода(количество тиков) для таймера, обеспечивающего задержку. 100 000/10 000 = 10 Гц. 10 Гц = 0.1 с

#define PORT_MANAGE_DYN GPIOA
#define PIN_MANAGE_DYN GPIO_Pin_1

#define pi 3.14159265358979323846

// типовой вариант функции assert
void assert_failed(uint8_t* file, uint32_t line)
{ 
  while (1)
  {
	;
  }
}

void Set_Pin()                                               // настройка подключения периферии
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE);     // тактирую порт А
	
  GPIO_InitTypeDef gpioStruct;                               // структура сигнального пина
  GPIO_StructInit(&gpioStruct);
	gpioStruct.GPIO_Speed = GPIO_Speed_2MHz;
	gpioStruct.GPIO_Mode = GPIO_Mode_AF_PP;                    // буду использовать альтернативный режим, а не обычный GPIO
	gpioStruct.GPIO_Pin = PIN_MANAGE_DYN;                      // настроим ногу (PА1) к которой подключен динамик
  GPIO_Init(PORT_MANAGE_DYN, &gpioStruct);
}

void Set_Timer()
{
	// настройка базового таймера
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);       // тактирую таймер 2
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);       // тактирую таймер 3
                                                             // Частота счёта, отсчет ведется каждые - 1 мкс, частота ШИМ - 200 кГц
	TIM_TimeBaseInitTypeDef Tim;                               // создаю экземпляр структуры, которая задает частоту через предделитель, период и направление счета
  TIM_TimeBaseStructInit(&Tim);                              // заполняю структуру значениями по умолчанию
	Tim.TIM_Prescaler = PWM_PRESCALER;                       // предделитель для таймера
	Tim.TIM_Period = PWM_PERIOD;                             // период 
	TIM_TimeBaseInit(TIM2, &Tim);                              // инициализирую таймер
                       
	TIM_TimeBaseInit(TIM3, &Tim);  
	
	// настройка канала ШИМа
	TIM_OCInitTypeDef TimPWM;                                  // конфигурация выхода таймера. Структура для генерации ШИМ
	TIM_OCStructInit(&TimPWM);
	TimPWM.TIM_OCMode = TIM_OCMode_PWM1;                       // конфигурируем выход таймера, режим PWM1 
	TimPWM.TIM_OutputState = TIM_OutputState_Enable;           // выход включен
	TIM_OC2Init(TIM2, &TimPWM);                                // заношу данные во 2ой канал
	
	TIM_ITConfig(TIM2,TIM_IT_Update, ENABLE);                  // режим генерации прерывания по обновлению, переполнению
	TIM_ITConfig(TIM3,TIM_IT_Update, ENABLE);   
	TIM_Cmd(TIM2, ENABLE);                                     // запуск таймера
}

/*
sin(A). Величина A задает значение синуса в радианах. Точность задаваемой скважности зависит от дискретизации значений. 
Поэтому я решил как можно больше значений, в итоге взял 512. Разбил единичную окружность на 512 отрезков.
Сигнал по синусу меняется от -1 до 1. Отрицательное напряжение я не сгенерирую, поэтому поднимаю график на 1 по оси Y. Теперь сигнал меняется от 2 до 0, формула приобретает вид: sin(А)+1.
Т.к. регистр TIM2->ССR2 16-битный, для него максимальное значение 65535, до множим нашу формулу на 65535/2 = 32767,
чтобы максимально приблизится к 65535, в итоге формула у нас имеет вид: (sin (А)+1)*65535/2. А сигнал меняется от 32767 до 65535 по закону синуса.

Чтобы менять высоту тона, я изменял частоту разбиений при последовательной выборке значений.

Чтобы определить частоту генерируемого звукового сигнала, надо поделить частоту дискретизации на количество элементов соответствующего массива.
Нам необходимо знать количество элементов в массиве: частота дискретизации/ частоту звукового сигнала = 180 000/частоту сигнала
Частота дискретизации: 180 000 Гц
Из справочных данных: 
- нота До 3ьей октавы: 1046 Гц 
- нота Ми 3ьей октавы: 1318 Гц 
- нота Соль 3ьей октавы: 1568 Гц 

Получаем:
- для ноты До 1720 элементов
- для ноты Ми 1360 элементов
- для ноты Соль 1140 элементов

Для увеличения громкости я увеличил разбиение в 10 раз. 

В качестве аккорда я выбрал аккорд С. 
Он состоит из нот:
- До
- Ми
- Соль
*/

void Delay(uint16_t delay)                           			    // функция, обеспечивающая задержку.
{
	TIM3->PSC = 36;             										            // установка предделителя таймера. 72 000 000/72 = 1 000 000 Гц.
	TIM3->ARR = delay;                                        
	TIM_Cmd(TIM3, ENABLE);         														  // в момент вызова произвести запуск таймера
	while((TIM3->SR & TIM_SR_UIF)==0)                           //дождаться конца задержки
	{
	}		
  TIM_ClearITPendingBit(TIM3,TIM_IT_Update);	               //сбросить флаг
}

uint16_t do_sin[1720] = {0};                                   // массив элементов для записи значений ноты До
uint16_t mi_sin[758] = {0};                                   // массив элементов для записи значений ноты Ми
uint16_t sol_sin[1140] = {0};                                  // массив элементов для записи значений ноты Соль
  
// функция расчета значений синусов
void Sine()                                                        
{  
// 	for (int j = 0; j <= 1720; j++)
// 	{	
// 		do_sin[j] = (uint16_t)((sin(j*pi/860)+1)*65535/2);         // массив расчета значений синуса для ноты До
// 	}
	for (int j = 0; j <= 756; j++)
	{	
		mi_sin[j] = (uint16_t)((sin(j*pi/378)+1)*450);         // массив расчета значений синуса для ноты Ми
	}
// 	for (int j = 0; j <= 1140; j++)
// 	{	
// 		sol_sin[j] = (uint16_t)((sin(j*pi/570)+1)*65535/2);         // массив расчета значений синуса для ноты Соль
// 	}
}

// нота До
// void Do()
// {                                                
// 	for(int i=0; i <= 1720; i++)                                  // i задает дискретизацию единичной окружности для расчета в каждой точке значения синуса
// 	{
// 		TIM2->CCR2 = do_sin[i];                                     // измение заполнения ШИМ сигнала                                            
// 	}
// }
// нота Ми
void Mi()
{    																			        
	for(int i=0; i <= 758; i++)                                 
	{
		TIM2->CCR2 = mi_sin[i];
    Delay(2);		
	}
}

// нота Соль
// void Sol()
// {                                                      
// 	for(int i=0; i <= 1720; i++)                                  
// 	{
// 		TIM2->CCR2 = sol_sin[i];                                                  
// 	}
// }

/*
Для одновременного воспроизведения сразу нескольких нот складываю значения их текущих амлитуд (из массивов). 
Чтобы избежать переполнения,делим получившуюся сумму на количество звучащих нот. 
И так каждые 100 микросекунд.
*/

// uint16_t chord_sin[1720] = {0};                                           //Количество элементов в складываемых массивах (max 1720) и в результирующий помещаем 1720 элементов

// // функция расчета значений синуса для аккорда
// void Chord_Sine()                                                         
// {                                          
// 	for (int j = 0; j <= 1720 ; j++)
// 	{
// 		chord_sin[j] = (uint16_t)((do_sin[j] + mi_sin[j]+ sol_sin[j])/3);     //Сложение двух элементов с одинаковыми индексами
// 	}
// }

/*
Для того, чтобы проиграть аккорд можно было бы услышать, 
пришлось изменить значения предделителя частоты таймера и частоты дискретизации звукового сигнала.
Связано это с тем, что сигнал аккорда получился не совсем синусоидальный после наложения амплитуд, и для того,
чтобы человеческое ухо его зафиксировало, пришлось уменьшить частоту.
*/
// void Chord()
// {
// 	TIM2->PSC = 12;                                                         // 72000000/12 =  6 000 000 = 6 МГц
// 	TIM2->ARR = 14000;                                                			// 6 000 000/14 000 =  486 = 486 Гц
// 	for(int i = 0; i <= 1720; i++)                                          // i задает дискретизацию единичной окружности для расчета в каждой точке значения синуса
// 	{
// 		TIM2->CCR2 = chord_sin[i];                                            // измение заполнения ШИМ сигнала  
// 	}
// }

int main()
{
	Set_Pin();
	Set_Timer();
	Sine();
// 	Chord_Sine();
	while(1)
	{
// 		Chord();
 		Mi();
// 		Do();
// 		Sol();
	}
	return 0;
}
	